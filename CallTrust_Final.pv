(* ========================== CallTrust: ProVerif model (revised fix) ========================== *)

(* CallTrust protocol

Message 1: u -> AP : { k_up }pk_AP, { n_u }k_up 
Message 2: AP -> u : OTP #on a DIFFERENT PRIVATE channel 
Message 3: u -> AP : { pk_u , OTP }k_up 
Message 4: AP -> u : { n_u, pk_u }sk_AP 
Message 5: CS -> u : n_CS #on a DIFFERENT PUBLIC channel
Message 6: u -> TLP : n_CS 
Message 7: TLP -> u : { n_CS, pk_CS }sk_TP 
Message 8: u -> CS : { k_uc }pk_CS, { { n_u, pk_u }sk_AP }k_uc 
Message 9: CS -> u : { R_uc }k_uc 
Message 10: u -> CS : { { R_uc }sk_u }k_uc 
Message 11: CS -> u : { s }k_uc
Message 12: CS -> u : HMAC(s, Z) #HMAC is a message authentication code Message 

*)
set preciseActions = true.
set ignoreTypes = false.

(* --- Channels --- *)
free c        : channel.              (* global public channel *)
free tel_pub    : channel.              (* public “phone call” channel *)
free tel_priv : channel [private].    (* private out-of-band channel for OTP *)

(* --- Public constants --- *)
type phone.
free n_CS : phone.                    (* public phone number of CS *)
free n_u  : phone.                    (* USER phone number (was bitstring, now type phone) *)

(* --- Cryptographic primitives --- *)

(* Public-key encryption *)
type skey.
type pkey.
fun  pk(skey)                       : pkey.
fun  aenc(bitstring, pkey)          : bitstring.
reduc forall m:bitstring, k:skey; adec(aenc(m, pk(k)), k) = m.

(* Digital signatures with message recovery (honest processes should use checksign) *)
type sskey.
type spkey.
fun  spk(sskey)                     : spkey.
fun  sign(bitstring, sskey)         : bitstring.
reduc forall m:bitstring, k:sskey; getmess(sign(m,k))           = m.
reduc forall m:bitstring, k:sskey; checksign(sign(m,k), spk(k)) = m.

(* Symmetric encryption (use nonces as symmetric session keys) *)
type nonce.
fun  sencrypt(bitstring, nonce)     : bitstring.
reduc forall x:bitstring, y:nonce; sdecrypt(sencrypt(x,y), y) = x.

(* HMAC primitive (modeled as an unforgeable constructor under unknown key) *)
fun hmac(bitstring (*key*), bitstring (*message*)) : bitstring.

(* Type converter *) 
(* fun phonetobitstring ( phone ) : bitstring [ data , typeConverter ] . *)

letfun choose(x: phone, y: phone, u: phone) = if x = u then y else x.
 

(* --- Tags --- *)
free c_kup, c_phone, c_pkuotp, c_cert, c_kuc, c_fwdcert, c_R, c_sigR, c_s, c_pb, c_p1, c_p2: bitstring.

(* --- TLP phonebook (number -> public key) --- *)
table phonebook(phone, pkey).
table user_seedtable(phone, bitstring).
table cs_seedtable(phone, bitstring).


(* --- Events --- *)
event AP_issue_certificate_u(phone, spkey, bitstring).
event u_contact_AP(phone, spkey, bitstring).
event u_validate_hmac(phone,phone,bitstring,nonce).
event cs_call_involved(phone,phone,bitstring,nonce).
event TLP_send_info(phone, pkey, nonce).
event u_validate_info(phone, pkey, nonce).

(* AP should only validate a user if that user actually began a session *)
(*query x: phone, pk: spkey;
  inj-event(ap_validated(x, pk)) ==> inj-event(u_begins(pk, x)).*)

free secretMessage : bitstring [ private ] .
query attacker ( secretMessage ).

fun bitstring_to_nonce ( bitstring ) : nonce [ data , typeConverter ]. 

query x: phone, y: phone, s:bitstring, k:nonce;
  inj-event(u_validate_hmac(x, y, s, k)) ==> inj-event(cs_call_involved(x, y, s, k)).

query x: phone, y: spkey, s:bitstring;
  inj-event(AP_issue_certificate_u(x, y, s)) ==> inj-event(u_contact_AP(x, y, s)).

query x: phone, y: pkey, k:nonce;
  inj-event(u_validate_info(x, y, k)) ==> inj-event(TLP_send_info(x, y, k)).

query  x: phone, y: phone, s:bitstring, k:nonce; event(u_validate_hmac(x, y, s, k)).



(* USEFUL MACROS *)

let Ufollowing(n_x: phone, n_y: phone, pk_u: spkey, sk_u: sskey, spkTL: spkey, cert_from_AP: bitstring, pk_other : pkey) =

  (* Msg 8 *)
  new k_uc : nonce;
  out(c, ( aenc( (c_kuc, k_uc), pk_other ),
          sencrypt( (c_fwdcert, cert_from_AP), k_uc ) ));

  (* Msg 9 *)
  in(c, m9: bitstring);
  let (=c_R, R_uc : bitstring) = sdecrypt(m9, k_uc) in

  (* Msg 10 *)
  let sigR = sign((c_sigR, R_uc), sk_u) in
  out(c, sencrypt(sigR, k_uc));

 (* Msg 11 *)
  in(c, (enc_s: bitstring));
  let (=c_s, s : bitstring) = sdecrypt(enc_s, k_uc) in

  (* Msg 12 *)
  in(c, (mac_recv: bitstring));

  let Z = (n_x, n_y) in
  if hmac(s, Z) = mac_recv then (
   if n_x = n_CS || n_y=n_CS then event u_validate_hmac(n_x, n_y, s, k_uc); 
   out( c , sencrypt(secretMessage, bitstring_to_nonce(s)))
  ) else 0.


let CSfollowing(n_x: phone, n_y: phone, skCS_enc: skey, spkAP: spkey, pkCS: pkey, seed: bitstring) =
  in(c, (enc_kuc: bitstring, enc_cert: bitstring));
  let (=c_kuc, k_uc : nonce) = adec(enc_kuc, skCS_enc) in
  event cs_call_involved(n_x, n_y, seed, k_uc);
  let (=c_fwdcert, certA : bitstring) = sdecrypt(enc_cert, k_uc) in
  let (=c_cert, nu_phone: phone, pk_u : spkey) = checksign(certA, spkAP) in
  if (n_x = n_CS && nu_phone = n_y ) || (n_y = n_CS && nu_phone = n_x ) then

    new R_uc : bitstring;
    out(c, sencrypt( (c_R, R_uc), k_uc ));

    in(c, enc_sigU: bitstring);

    let sigU = sdecrypt(enc_sigU, k_uc) in
    let (=c_sigR, =R_uc) = checksign(sigU, pk_u) in

    out(c, ( sencrypt( (c_s, seed), k_uc ) ));

    let Z = (n_x, n_y) in
    let mac = hmac(seed, Z) in
    out(c, mac ).


(* -----------------------------------------------------------------------------
   Role: User (u)
----------------------------------------------------------------------------- *)
let processU(pkAP : pkey, spkAP : spkey, spkTL : spkey,
             pk_u : spkey, sk_u : sskey) =

  (* Msg 1 *)
  new k_up  : nonce;
  out(c, ( aenc((c_kup, k_up), pkAP), sencrypt( ( c_phone, n_u ), k_up) ));

  (* Msg 2 *)
  in(tel_priv, OTP : bitstring);
  event u_contact_AP(n_u, pk_u, OTP); 

  (* Msg 3 *)
  out(c, sencrypt( (c_pkuotp, pk_u, OTP), k_up ));

  (* Msg 4 *)
  in(c, ms4: bitstring);
  let (=c_cert, =n_u, =pk_u) = checksign(ms4, spkAP) in
  let cert_from_AP = ms4 in

  (* Msg 5: attacker provides (n_x, n_y) *)
  in(c, (n_x: phone, n_y: phone));

  if n_x= n_u || n_y=n_u then
    let other: phone = choose(n_x, n_y, n_u) in
    new nonce_u : nonce;
    out(c, (other, nonce_u) );
    in(c, ms7: bitstring);
    let (=c_pb, =other, pk_other : pkey, =nonce_u) = checksign(ms7, spkTL) in
    event u_validate_info(other, pk_other, nonce_u);
    Ufollowing(n_x, n_y, pk_u, sk_u, spkTL, cert_from_AP, pk_other).



(* -----------------------------------------------------------------------------
   Role: AP (unchanged)
----------------------------------------------------------------------------- *)
let processAP(skAP_enc : skey, skAP_sig : sskey) =
  in(c, m1: bitstring);
  let (part1: bitstring, part2: bitstring) = m1 in
  let (=c_kup, k_up : nonce) = adec(part1, skAP_enc) in
  let (=c_phone, nu_phone: phone) = sdecrypt(part2, k_up) in
  new OTP : bitstring;
  out(tel_priv, OTP);
  in(c, m3: bitstring);
  let (=c_pkuotp, pk_u : spkey, otp2 : bitstring) = sdecrypt(m3, k_up) in
  if otp2 = OTP then (
    event AP_issue_certificate_u(nu_phone, pk_u, OTP); 
    out(c, sign( (c_cert, nu_phone, pk_u), skAP_sig ))
  ) else 0.

(* -----------------------------------------------------------------------------
   Role: TLP (unchanged)
----------------------------------------------------------------------------- *)
let processTLP(skTL_sig : sskey) =
  in(c, (num: phone, nonce_u: nonce));
  get phonebook(=num, pk_num : pkey) in
  event TLP_send_info(num, pk_num, nonce_u);
  out(c, sign( (c_pb, num, pk_num, nonce_u), skTL_sig )).

(* -----------------------------------------------------------------------------
   Role: CS
----------------------------------------------------------------------------- *)
let processCS(skCS_enc : skey, spkAP : spkey, pk_u : spkey, pkCS: pkey) =
  in(c, (n_x: phone, n_y: phone));
  new seed : bitstring;
  CSfollowing(n_x, n_y, skCS_enc, spkAP, pkCS,seed).


(* -----------------------------------------------------------------------------
   Phonebook registration
----------------------------------------------------------------------------- *)
let processK =
  in(c, (num: phone, k: pkey));
  if num <> n_CS then insert phonebook(num, k).

(* -----------------------------------------------------------------------------
   System initialization
----------------------------------------------------------------------------- *)
process
  new skAP_enc : skey;  let pkAP  = pk(skAP_enc)  in out(c, pkAP);
  new skAP_sig : sskey; let spkAP = spk(skAP_sig) in out(c, spkAP);
  new skTL_sig : sskey; let spkTL = spk(skTL_sig) in out(c, spkTL);
  new skCS_enc : skey;  let pkCS  = pk(skCS_enc)  in insert phonebook(n_CS, pkCS);
  new sk_u  : sskey;   let pk_u = spk(sk_u) in out(c, pk_u);


  (  (!processU(pkAP, spkAP, spkTL, pk_u, sk_u))
   | (!processAP(skAP_enc, skAP_sig))
   | (!processTLP(skTL_sig))
   | (!processCS(skCS_enc, spkAP, pk_u, pkCS))
   | (!processK)
  )
